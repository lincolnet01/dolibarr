name: Deploy/Destroy Customer Dolibarr Instance

on:
  workflow_dispatch:
    inputs:
      customer_name:
        description: "Customer name (lowercase alphanumeric + hyphens, 3-20 chars)"
        required: true
        type: string
      dolibarr_version:
        description: "Dolibarr image tag (tuxgasy/dolibarr)"
        required: false
        default: "19"
        type: string
      action:
        description: "Action to perform"
        required: true
        type: choice
        options:
          - deploy
          - destroy

env:
  NAMESPACE: dolibarr-${{ github.event.inputs.customer_name }}
  DOMAIN: ${{ github.event.inputs.customer_name }}.moyocorps.com
  VPS_HOST: 185.192.96.209
  VPS_USER: prime

jobs:
  validate:
    name: Validate Inputs
    runs-on: ubuntu-latest
    steps:
      - name: Validate customer_name
        run: |
          NAME="${{ github.event.inputs.customer_name }}"
          if [[ ! "$NAME" =~ ^[a-z0-9][a-z0-9-]{1,18}[a-z0-9]$ ]]; then
            echo "::error::customer_name must be 3-20 chars, lowercase alphanumeric + hyphens, cannot start/end with hyphen"
            exit 1
          fi
          echo "Customer: $NAME"
          echo "Namespace: dolibarr-$NAME"
          echo "Domain: $NAME.moyocorps.com"

  deploy:
    name: Deploy Customer Instance
    needs: validate
    if: github.event.inputs.action == 'deploy'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -H ${{ env.VPS_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Verify SSH connectivity
        run: ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "kubectl cluster-info"

      - name: Render templates
        run: |
          mkdir -p k8s/rendered
          for file in k8s/templates/*.yaml; do
            sed \
              -e "s|__CUSTOMER_NAME__|${{ github.event.inputs.customer_name }}|g" \
              -e "s|__CUSTOMER_NAMESPACE__|${{ env.NAMESPACE }}|g" \
              -e "s|__CUSTOMER_DOMAIN__|${{ env.DOMAIN }}|g" \
              -e "s|__DOLIBARR_VERSION__|${{ github.event.inputs.dolibarr_version }}|g" \
              "$file" > "k8s/rendered/$(basename $file)"
          done
          echo "--- Rendered templates ---"
          ls -la k8s/rendered/

      - name: Copy rendered templates to VPS
        run: |
          REMOTE_DIR="/tmp/dolibarr-deploy-${{ github.event.inputs.customer_name }}"
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "mkdir -p $REMOTE_DIR"
          scp k8s/rendered/*.yaml ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:$REMOTE_DIR/

      - name: Create namespace
        run: |
          REMOTE_DIR="/tmp/dolibarr-deploy-${{ github.event.inputs.customer_name }}"
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "kubectl apply -f $REMOTE_DIR/namespace.yaml"

      - name: Create secrets (if not exists)
        run: |
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} bash <<'SCRIPT'
          NAMESPACE="${{ env.NAMESPACE }}"
          if kubectl get secret dolibarr-secrets -n "$NAMESPACE" >/dev/null 2>&1; then
            echo "Secrets already exist — skipping (passwords preserved)"
          else
            MYSQL_ROOT_PASSWORD=$(openssl rand -base64 24)
            MYSQL_PASSWORD=$(openssl rand -base64 24)
            DOLI_ADMIN_PASSWORD=$(openssl rand -base64 16)

            kubectl create secret generic dolibarr-secrets \
              -n "$NAMESPACE" \
              --from-literal=MYSQL_ROOT_PASSWORD="$MYSQL_ROOT_PASSWORD" \
              --from-literal=MYSQL_PASSWORD="$MYSQL_PASSWORD" \
              --from-literal=DOLI_ADMIN_PASSWORD="$DOLI_ADMIN_PASSWORD"

            echo "Secrets created with auto-generated passwords"
          fi
          SCRIPT

      - name: Apply ConfigMap
        run: |
          REMOTE_DIR="/tmp/dolibarr-deploy-${{ github.event.inputs.customer_name }}"
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "kubectl apply -f $REMOTE_DIR/configmap.yaml"

      - name: Deploy MariaDB
        run: |
          REMOTE_DIR="/tmp/dolibarr-deploy-${{ github.event.inputs.customer_name }}"
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} bash <<SCRIPT
          kubectl apply -f $REMOTE_DIR/mariadb-pvc.yaml
          kubectl apply -f $REMOTE_DIR/mariadb-deployment.yaml
          kubectl apply -f $REMOTE_DIR/mariadb-service.yaml
          echo "Waiting for MariaDB rollout..."
          kubectl rollout status deployment/mariadb -n ${{ env.NAMESPACE }} --timeout=120s
          SCRIPT

      - name: Deploy Dolibarr
        run: |
          REMOTE_DIR="/tmp/dolibarr-deploy-${{ github.event.inputs.customer_name }}"
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} bash <<SCRIPT
          kubectl apply -f $REMOTE_DIR/dolibarr-pvc.yaml
          kubectl apply -f $REMOTE_DIR/dolibarr-deployment.yaml
          kubectl apply -f $REMOTE_DIR/dolibarr-service.yaml
          echo "Waiting for Dolibarr rollout (up to 300s for first-time auto-install)..."
          kubectl rollout status deployment/dolibarr -n ${{ env.NAMESPACE }} --timeout=300s
          SCRIPT

      - name: Apply Ingress
        run: |
          REMOTE_DIR="/tmp/dolibarr-deploy-${{ github.event.inputs.customer_name }}"
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "kubectl apply -f $REMOTE_DIR/ingress.yaml"

      - name: Clean up temp files on VPS
        if: always()
        run: |
          REMOTE_DIR="/tmp/dolibarr-deploy-${{ github.event.inputs.customer_name }}"
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "rm -rf $REMOTE_DIR" || true

      - name: Deployment summary
        run: |
          echo "============================================"
          echo "  DEPLOYMENT COMPLETE"
          echo "============================================"
          echo ""
          echo "  Customer:  ${{ github.event.inputs.customer_name }}"
          echo "  Namespace: ${{ env.NAMESPACE }}"
          echo "  URL:       https://${{ env.DOMAIN }}"
          echo "  Version:   tuxgasy/dolibarr:${{ github.event.inputs.dolibarr_version }}"
          echo ""
          echo "  Admin user: admin"
          echo "  Get admin password:"
          echo "    ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} \"kubectl get secret dolibarr-secrets -n ${{ env.NAMESPACE }} -o jsonpath='{.data.DOLI_ADMIN_PASSWORD}' | base64 -d\""
          echo ""
          echo "============================================"
          echo ""
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "kubectl get all -n ${{ env.NAMESPACE }}"

  destroy:
    name: Destroy Customer Instance
    needs: validate
    if: github.event.inputs.action == 'destroy'
    runs-on: ubuntu-latest
    steps:
      - name: Set up SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -H ${{ env.VPS_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Verify namespace exists
        run: |
          if ! ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "kubectl get namespace ${{ env.NAMESPACE }}" >/dev/null 2>&1; then
            echo "::error::Namespace ${{ env.NAMESPACE }} does not exist — nothing to destroy"
            exit 1
          fi
          echo "Namespace ${{ env.NAMESPACE }} found — proceeding with deletion"

      - name: Delete namespace (cascades all resources)
        run: |
          echo "Deleting namespace ${{ env.NAMESPACE }} and ALL resources within it..."
          ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "kubectl delete namespace ${{ env.NAMESPACE }} --wait=true --timeout=120s"
          echo ""
          echo "============================================"
          echo "  DESTROY COMPLETE"
          echo "============================================"
          echo ""
          echo "  Customer:  ${{ github.event.inputs.customer_name }}"
          echo "  Namespace: ${{ env.NAMESPACE }} (deleted)"
          echo "  All resources including PVCs/data have been removed."
          echo ""
          echo "============================================"
